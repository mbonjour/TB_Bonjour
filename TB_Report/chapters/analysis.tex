\chapter{Analyse - État de l'art}
\label{ch:analysis}
%todo utilisation emails globales
\noindent La problématique principale est la difficulté d’utilisation des sécurités mises en places au-dessus des protocoles de base pour les emails. 
De plus des vulnérabilités (EFAIL en \ref{attacks:EFAIL}) qui réussissent à récupérer le texte clair a démontré que la sécurité n’était pas bien implémentée. Les vulnérabilités proviennent plus d'un défaut de conception inhérent aux mails.
Je vais ici décrire les principaux problèmes trouvés sur PGP et S/MIME lors de mes tests d’utilisation et ce que j’ai trouvé durant mes recherches. De plus je vais analyser des systèmes de mails sécurisés tel que Protonmail et Tutanota.
\section{Protocoles existants}
Ici je vais regarder les protocole existants afin de mettre en place des liaisons sécurisées de messagerie éléctronique.
%todo ajouter fonctions techniques - choix des users des suites crypto
\subsection{PGP}
\paragraph*{Fonctionnement.}
PGP (Pretty Good Privacy ou Assez bonne confidentialité) est un moyen de chiffrer des données (mails, fichiers, …) qui est beaucoup représenté lorsque l’on parle de sécurité email car c’est le plus utilisé avec S/MIME (c.f. \ref{protocols:SMIME}). C’est une méthode de chiffrement hybride (utilise le chiffrement symétrique et assymétrique) qui fonctionne comme montré sur la Figure \ref{fig:PGP_101}.

\begin{figure}[h!]
\includegraphics[width=10cm]{images/PGP_101.png}
\centering
\caption{Le fonctionnement global de PGP}
\label{fig:PGP_101}
\end{figure}

\noindent Ce fonctionnement hybride est défendu à cause de la lenteur et la non-praticité d’un chiffrement asymétrique sur un certain nombre de données. Ainsi en chiffrant uniquement la clé symétrique qui a servi à chiffrer le tout l’on peut déchiffrer bien plus rapidement et simplement le message (typiquement avec un chiffrement symétrique tel qu’AES qui a le droit à des instructions dédiées dans certains processeurs). Contrairement à des chiffrements asymétriques qui sont plus contraignants. Et l'on n'utilise pas directement le chiffrement symétrique car il a besoin d'un secret partagé dès le début de la communication.
PGP utilise un système de clés… PGP est aussi critiqué pour son manque de "Forward Secrecy"...
\paragraph*{Propriétés cryptographiques.}
Le problème qui est souvent reproché à PGP c'est qu'il n'implémentes pas de \textit{Forward Secrecy}. La \textit{Forward Secrecy} permet d'affirmer que si l'on a une brèche à un instant \textit{T}, et qu'un attaquant récupère cette clé, il ne pourra pas déchiffrer les anciens messages.
De plus, la gestion des clés PGP est très problématique, en effet lors de mes tests il était difficile de connecter un serveur de clés p. ex. Ou de recevoir une clé d'un correspondant pour la sauvegarder. Et même en la recevant, comment savoir si cette clé n'a pas été modifiée via un \textit{MITM} p.ex. ? -> utiliser un autre canal pour vérifier l'empreinte.
\paragraph*{Web of Trust.}
Comment faire confiance a une clé -> surtout pour email -> Comment initialiser une confiance ?
\paragraph*{Autocrypt.}
Autocrypt est une manière d'échanger des clés entres emails, ces échanges ne sont pas considérés sécurisé par la communauté (Wikipedia -> à creuser). C'est une façon de s'échanger des clés de manière automatisée mais pas forcément sécurisée (utilise les mails).
\paragraph*{Utilisation.}
Pour mes tests j’ai fait en sorte de trouver l’utilisation la plus simple possible pour voir si un utilisateur lambda pouvait arriver à mettre en place ce genre de sécurité. Il s’est avéré que cela était assez simple au départ, mais dès lors que l'on veut envoyer un mail chiffré à un correspondant cela se complique un peu. J’ai juste eu à installer un Add-On sur mon logiciel de messagerie (Thunderbird dans mon cas) qui s’appelle Enigmail. Ensuite Enigmail a générer mes clés PGP (de manière totallement opaque -> à creuser). Puis j’ai écrit un mail, en appuyant sur un petit cadenas mon mail partait chiffré et signé (uniquement si on a la clé du correspondant). Bien, cependant c’est très opaque et on ne sait pas ce qu'Enigmail et Autocrypt font réellement derrière les décors. L’utilisateur doit encore choisir s’il veut chiffrer ses mails ou non par contre il faut que le destinataire utilise PGP et que l’on ait sa clé publique. 
J’ai donc expérimenté à plus bas niveau ce qu’il se passait.
%TODO Aller dans les détails
\subsection{PEP}
\paragraph*{Citation.}
\textit{By default, communications between pep peers always work end-to-end encrypted – no eavesdrop-ping in between shall be possible by design.}
\paragraph*{Utilisation.}
pep assure un chiffrement de bout-en-bout par design, ils n'ont en effet pas de serveurs en soit et chiffre à l'aide d'un \textit{handshake} fait entres les deux personnes via des \textit{trustwords}. Ce sont des mots qu'il faut vérifier entres les deux partis afin d'être sûr que la connexion est bien authentifiée.
\begin{figure}[h!]
    \includegraphics[width=15cm]{images/conceptualpEp.png}
    \centering
    \caption{Le fonctionnement global de pEp}
    \label{fig:PEP_global}
\end{figure}
-> à creuser mais à priori PEP utilise PGP pour le chiffrement des messages.
\subsection{S/MIME}
\label{protocols:SMIME}
\paragraph*{Fonctionnement.}
Basé sur le même principe que PGP principalement, mais avec des certificats pour prouver la légitimité des clés publiques. Pour l'utilisation il faut se créer un certificat, plusieurs classes de confiance existe. 
\paragraph*{Propriétés cryptographiques.}
\paragraph*{Utilisation.}
\section{Implémentations existantes}
\subsection{Protonmail}
\paragraph*{Revendications.}
Protonmail revendique beaucoup de propriétés cryptographiques, tel que le zero-access encryption. Et l’end-to-end chiffrement + zero-knowledge pour les messages sécurisés, même avec leur fonctionnalité de (Chiffrement vers l'extérieur) utilisant AES256-GCM. 
Pour l'authentification Protonmail utilise une manière fortement sécurisée (SRP) pour ne pas avoir d'informations direct sur le mot de passe de l'utilisateur.
\paragraph*{Fonctionnement.}
Protonmail a plusieurs modes de fonctionnement dépendant du destinataire final. En effet de Protonmail à Protonmail les mails sont chiffrés à l'aide de PGP automatiquement. L'on peut utiliser Protonmail pour utiliser PGP si l'on a la clé de notre destinataire par exemple. Et l'on peut écrire un mail chiffré à quelqu'un qui n'utilise pas PGP grâce à une fonctionnalité de chiffrement vers l'extérieur.
Cette fonctionnalité enverra une URL au destinataire qui, en la consultant, pourra déchiffrer le mail en utilisant un mot de passe communiqué de manière sécurisées entres les deux partis auparavant.
\paragraph*{Open Source.}
Tout leur code est open-source afin d'avoir une validation externe, de plus ils ont un programme de Bug Bounty pour les chercheurs.
\subsection{Tutanota}
\paragraph*{Fonctionnement.}
Tout ce que j'ai vu pour le moment c'est que Tutanota utilise AES128-CBC ? Mais dans PGP ou ailleurs ?
%\subsection{Bitmessage}
\section{Attaque existantes}
\subsection{Défauts webmail}
Selon un chercheur~\cite{DBLP:journals/iacr/Kobeissi18a} l'infrastructure de Protonmail aurait des failles via son webmail. Mais son papier est en fait plus général et parle des webmails en règle général.
Il part du principe que les serveurs de Protonmail ne sont pas des serveurs à faire confiance, pour ainsi prouver le zero-knowledge de Protonmail. Par contre, le fait qu'il ne peuvent pas être mis en confiance est un problème selon lui, car c'est ces serveurs qui vont délivrer le code d'OpenPGP afin de faire le chiffrement. 
Cela indique que si Protonmail était corrompu le fait d'avoir le code délivré par Protonmail pourrait avoir des effets néfastes. Comme p.ex l'extraction de la clé privée PGP. La conclusion est que dès le moment où vous avez utilisé une fois le webmail de protonmail la clé PGP est corrompue.
\subsection{EFAIL}
\label{attacks:EFAIL}
Malgré ces sécurités qui pourraient être mises en place à l’heure actuelle, une attaque nommée EFAIL~\cite{DBLP:conf/uss/PoddebniakD0ISF18} a été faite en 2018 et est toujours possible aujourd’hui(à vérifier / tester). En effet cette attaque a seulement été mitigée en évitant d’afficher les contenus HTML et les images dans boites mails de base. Car le problème vient de là principalement, des problèmes sont liés aussi aux modes de chiffrement utilisé (typiquement CBC et CFB) grâce à des "gadgets".
Cette attaque permet en fait d'injecter une image dans l'HTML du message (typiquement dans les headers du mail), puis faire en sorte de récupérer le contenu du message déchiffrer dans un paramètre de l'URL.

\section{Signal}
L'analyse s'est faite aussi pour la messagerie instantanée à cause de sa ressemblance avec la messagerie électronique. 
%Cela m'a finalement permis de me rendre compte que ce n'était pas des protocoles idéaux.
%TODO compléter l'analyse sur Signal
\subsection{Fonctionnement}
%TODO commenter la figure
\begin{figure}[h!]
	\centering
	\includegraphics[width=8cm]{images/signalFonctionnement.png}
	\caption{Schéma fonctionnement de Signal\cite{doubleratchet}}
	\label{fig:signal}
\end{figure}
\subsection{Problèmes d'intégrations}
Le problème avec le protocole Signal quant à mes besoins niveaux mails est la \textit{forward secrecy} qui est très fort. En effet comme vu dans le chapitre précédent il utilise une clé par message grâce au \textit{Double Ratchet}. Cependant ce fonctionnement comporte un gros problème en rapport aux mails, en effet si l'on veut pouvoir récupérer les anciens mails reçus/envoyés cela devient vraiment compliqué. En effet, la \textit{forward secrecy} est une propriété utile dans un système de mail, mais faut pouvoir aussi récupérer les messages facilement si l'on connait la clé privée.
\section{Compromis}
Pour passer à l'implémentation concrète d'un nouveau protocole il faut faire des compromis et aller chercher dans des primitives moins connues.\\
Je suis tout de même rester sur un système de clés publiques comme PGP le fait. Cependant cette primitive a une identité propre à chaque clé publique.\\
De plus pour avoir une \textit{forward secrecy} l'on peut ajouter une notion de temps ou de token à l'ID pour chaque batch de messages.
\subsection{Résultats des recherches}
Comme mentionné avant les recherches ont beaucoup été orientées sur le protocole Signal qui a une très bonne forward secrecy, résilience et break-in recovery. Cependant le problème avec l'utilisation des mails c'est d'avoir envie de consulter tout ces mails depuis n'importe quel appareil. Ce n'est malheureusement pas le cas avec Signal à moins de conserver une \textit{root key} quelque part qui ferait s'effondrer les caractéristiques principales du protocole.\\
%TODO : Refaire ce paragraphe
S/MIME est la solution prédominante pour s'envoyer des mails chiffrés cependant il est compliquer de l'utiliser. En faisant quelques essais de mon côté je me suis heurté à beaucoup de difficultés et de problèmes avec les clés PGP.

\section{Primitives}
\subsection{Primitives analysées}
%TODO : Expliquer les différentes primitives
- Certificateless PKC~\cite{DBLP:conf/asiacrypt/Al-RiyamiP03}\\
- HIBE - Hierarchised Based encryption\\
- Identity based encryption
%TODO à compléter
\subsection{Primitive choisie}
- Certificateless PKC~\cite{DBLP:conf/asiacrypt/Al-RiyamiP03}\\
Tout d'abord le HIBE aurait été compliqué à mettre en place aussi à cause de sa forte forward secrecy, la hiérarchie doit de plus être commune sur tout les appareils, ce qui prendrait probablement du temps à un nouvel arrivage d'appareil pour un compte donné.
J'ai choisi cette primitive au final car elle proposait des propriétés très intéressantes pour ma manière d'implémenter dans les mails cela. En effet, similaire à de l'identity based avec un ID pour désigner une clé publique. Le problème avec l'identity based encryption c'est le fait que le serveur central génère la clé publique et la clé secrète de l'utilisateur, cela amène ce qu'on appelle le \textit{key escrow} problème. C'est le fait qu'une entité connaisse à elle seule toutes les clés. Ce problème est résolu dans le certificateless en introduisant des \textit{Partial Private Keys} permettant d'avoir une clé secrète partiellement générée par le serveur et par l'utilisateur.
\section{Recherches sur la primitive}
\subsection{Principes mathématiques}
Les variantes de \textit{Certificateless Cryptography} choisies utilisent un concept appelé les \textit{pairings} ou \textit{bilinear map groups}.
Des groupes tels que $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$ d'un ordre premier \textit{p} pour lesquels il existe un mapping $e : \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ avec les propriétés suivantes :\\
1. Bilinéarité : $e(g^a, h^b) = e(g, h)^{ab}$ pour tout $(g,h) \in \mathbb{G}_1 \times \mathbb{G}_2$ et $a,b \in \mathbb{Z}$;\\
2. Pas de dégénérescence : $e(g,h) \neq 1_{\mathbb{G}_T} $ tant que $g,h \neq 1_{\mathbb{G}_{1,2}}$;\\
%TODO : Détails mathématiques
\subsection{Schémas Certificateless de Chiffrement}
Pour choisir parmi les nombreux schémas existants en certificateless pour le chiffrement j'ai établi un tableau comparatif des différentes manières de faire, inspiré de~\cite{bookIntroCertificateless}. En suivant ce tableau je me suis rendu compte que la construction de Dent-Libert-Paterson~\cite{DBLP:conf/pkc/DentLP08} était probablement la plus adaptée en vue des propriétés qu'elle présentait. Le tableau se trouve en annexe \ref{ch:fichiers}.
%TODO Expliquer les propriétés
\subsection{Détails techniques}
Les détails techniques sur le chiffrement avec la \textit{Certificateless Cryptography}.
Le chiffrement se base sur le problème difficile \textit{The Decision 3-Party Diffie-Hellman Problem} (3-DDH). \\C'est de décider si $T =g^{abc} ayant (g^a, g^b, g^c, T) \in \mathbb{G}_4$.\\
Pour expliquer les détails techniques je vais ici montrer les calculs faits dans le schéma choisi~\cite{DBLP:conf/pkc/DentLP08} et les expliquer :\\
\textbf{Setup($1^k, n$) :} Avec $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$ avec un ordre $p > 2^k$. $g$ est un générateur de $\mathbb{G}_1$. Ensuite  $g_1 = g^\gamma$ pour un $\gamma \leftarrow  \mathbb{Z}_p^*$ aléatoire. Puis $g_2 \leftarrow \mathbb{G}_2$. Deux vecteurs (U,V) seront tirés aléatoirement dans $\mathbb{G}_2^{n+1}$ en tant que fonctions de hash notés :
\[F_u(ID) = \]
L'on va aussi prendre une fonction de hash résistante aux collisions : $H : \{0,1\}^* \rightarrow \{0,1\}^n$. Au final notre $mpk$ (master public key) est :
\[mpk \leftarrow (g, g_1, g_2, U, V)\]
Et le $msk$ (master seret key) est $msk \leftarrow g_2^\gamma$.
\\
\textbf{Extract($mpk, \gamma, ID$) :} On prend $r \leftarrow \mathbb{Z}_p^*$ puis on retourne $d_{ID} \leftarrow (d_1, d_2) = (g_2^\gamma * F_u(ID)^r, g^r)$\\
\textbf{SetSec($mpk$) :} Retourne un secret aléatoirement choisi $x_{ID} \leftarrow \mathbb{Z}_p^*$.\\
\textbf{SetPub($x_{ID}, mpk$) :} Retourne $pk_{ID} \leftarrow (X,Y) = (g^{x_ID}, g_1^{x_ID})$.\\
\textbf{SetPriv($x_{ID}, d_{ID}, mpk$) :} On choisit $r' \leftarrow \mathbb{Z}_p^*$ puis on reprends $(d_1, d_2) \leftarrow d_{ID}$ et l'on va prendre en secret key : 
%TODO : Revoir si assez complet :
\[sk_{ID} \leftarrow (s_1, s_2) = (d_1^{x_{ID}} * F_u(ID)^{r'}, d_2^{x_{ID}} * g^{r'})\]
Avec $sk_{ID}$ étant la clé secréte de l'utilisateur, donnée par l'Extract (notre Partial Private Key) et la valeur secrète de SetSec.\\
\textbf{Encrypt :}\\
\textbf{Decrypt :}
\subsection{Schémas Certificateless de Signature}
%TODO : Expliquer Malicious KGC et mettre tableaux
Pour choisir parmi les nombreux schémas certificateless pour la signature j'ai établi un tableau comparatif des différentes manières de faire inspiré de~\cite{bookIntroCertificateless}. En analysant les différentes possibilités dans ce tableau il y a peu de solutions se dégage, en effet l'on peut voir que beaucoup de schémas de signature sont cassés, mon choix s'est porté au final sur la construction de Zhang et Zhang~\cite{DBLP:conf/icc/ZhangZ08a} pour des signatures robustes en Certificateless. J'ai pris cette construction car elle est résistante au Malicious KGC (si le KGC a été setup avec des paramètres vulnérables) et en plus elle date de 2008 et n'a apparemment pas été cassée. Le tableau se trouve en annexe \ref{ch:fichiers}.
\subsection{Détails techniques}
Les détails techniques sur la signature avec la \textit{Certificateless Cryptography}.
La signature se base sur le problème difficile \textit{The ComputationalDiffie-Hellman Problem} (CDH). \\Ayant $P, aP, bP$ où $a,b$ aléatoires $\in \mathbb{Z}_q^*$ il n'est pas possible de trouver $abP$.\\
Pour expliquer les détails techniques je vais ici montrer les calculs faits dans le schéma choisi~\cite{DBLP:conf/icc/ZhangZ08a} et les expliquer :\\
\textbf{Setup :}\\
\textbf{Extract :}\\
\textbf{SetSec :}\\
\textbf{SetPub :}\\
\textbf{SetPriv :}\\
\textbf{Sign :}\\
\textbf{Verify :}
